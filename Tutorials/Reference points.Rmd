---
title: "Estimating reference points"
author: "Kyle L. Wilson"
date: "2025-10-11"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
      number_sections: true
    theme: journal
    highlight: espresso
    fig_retina: 3
    fig_caption: true
    fig_width: 7
    fig_height: 6
    smart: true
    df_print: tibble
bibliography: Fisheries_references.bib
csl: conservation-letters.csl
filters:
  - type: bib
    path: "Markdown/Metapop_references.bib"
  - type: pandoc-citeproc
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r source,echo=FALSE,warning = FALSE, message = FALSE}
library(mvtnorm)
library(marima)
library(diagram)
library(vioplot)
library(ggplot2)
```
## Population model
### Population dynamics

Our population is defined by as a species with a one year generation time with time-dynamics that follows birth (i.e., recruitment *R*) and death processes (i.e., fishing mortality *d*) such that:

\begin{align}
N_{t}=(1-d_{t})R_{t}
\end{align}

where $N_{i,t}$ is the number of adults at time *t*, $R_{i,t}$ is the number of recruits at time *t*, and $d_{t}$ is the fraction of recruits lost due to some source of mortliaty (i.e., harvest or disturbance).


### Beverton-Holt recruitment
Let's assume that our recruitment dynamics at time *t* depend on adult densities at *t-1*  following a reparameterized Beverton-Holt function based on compensation ratio [see Box 3.1 in @Walters2004] and ignoring age-structure so that we model adult-to-adult dynamics, i.e., setting $\phi_{E_{0}}=1$, $\phi_{B_{0}}=1$ and $R_0=N_0$ [see Table 3 in @Forrest2010]:

\begin{align}
R_{t}=\cfrac{{\alpha}N_{t-1}}{1+\cfrac{\alpha}{\beta}N_{t-1}}\epsilon_{t}
\end{align}

where $\alpha$ is the recruitment compensation ratio, $\beta$ is carrying capacity, and $\epsilon_{i,t}$ is lognormally distributed deviates to introduce stochastic recruitment dynamics.

```{r recruitment,echo=FALSE}
alpha <- c(2,4)
beta <- c(100,200)
```

For example, take a two different populations (Figure S1) that each vary in productivty $\alpha_1=2; \alpha_2=4$ and carrying capacity $\beta_1=100; \beta_2=200$. 

<br>
```{r recruit curves, echo=FALSE,warning = F, message = F,fig.hold=TRUE,fig.width=5.5, fig.height = 5,fig.cap="Density dependence in recruitment dynamics. Dashed line indicates the line of replacement, with equilbrium indicated by points. When populations fall below equilibrium points, per-capita productivity improves driving populations back towards equilibrium. When populations exceed their capacity, per-capita productivity decreases driving populations back towards equilibrium. At each point of the x-axis, the difference between the solid and dashed lines indicates the amount of recruitment above replacement, i.e., the surplus recruitment produced via compensatory density dependence.",fig.align="center"}
curve((alpha[1]*x)/(1+((alpha[1]-1)/beta[1])*x),from=0,to=2*beta[2],lwd=2,col="orange",xlab="Adults (t-1)",ylab="Recruits (t)",ylim=1.5*c(0,beta[2]),xlim=2*c(0,beta[2]))
curve((alpha[2]*x)/(1+((alpha[2]-1)/beta[2])*x),from=0,to=2*beta[2],lwd=2,col="dodgerblue",add=TRUE)
abline(b=1,a=0,lty=3,lwd=1.5,col="grey50")

curvedarrow(from=c(0.4*beta[2],0.75*beta[2]),to=c(beta[2],beta[2]),lwd=2,lty=1,lcol="black",arr.col="black",curve=-0.075,endhead=TRUE,arr.pos=0.5)
curvedarrow(from=c(1.575*beta[2],1.1*beta[2]),to=c(beta[2],beta[2]),lwd=2,lty=1,lcol="black",arr.col="black",curve=0.075,endhead=TRUE,arr.pos=0.5)

text(x=0.45*beta[2],y=0.88*beta[2],"Increased productivity",cex=0.5,srt=25)
text(x=1.60*beta[2],y=1.20*beta[2],"Decreased productivity",cex=0.5,srt=8.5)

points(c(beta),c(beta),pch=21,bg=c("orange","dodgerblue"))
legend("bottomright",c("Population 1","Population 2","Replacement"),bty="n",lwd=1.5,lty=c(1,1,3),pch=c(NA,NA,21),col=c("orange","dodgerblue","grey50"),pt.bg="grey50",cex=0.8)

```

## Sustainable Fisheries Framework: reference points
Based on these demographic parameters, we can use numerical methods to estimate various spawner, recruitment, or fisheries reference points. The most common ones are based on Maximum Sustainable Yield.

### Beverton-Holt or Ricker - same, same
Let's make a function that let's us tap into the same input parameters, but ask what the expected recruits would be under assumptions of a *Beverton-Holt* compared to a *Ricker* model.

```{r recruitment function}
alpha <- 5
beta <- 200
population_model <- function(alpha,beta,Nadults,model="Beverton-Holt")
{
  if(model=="Beverton-Holt")
  {
    # population model is R ~ (CR * S)/(1+(CR-1)/K * S): reparameterized Beverton-Holt
    recruits <- (alpha*Nadults)/(1+((alpha-1)/beta)*Nadults)
  }
  if(model=="Ricker")
  {
    # population model is R ~ CR * S * e(-log(CR)/K * S): reparameterized Ricker
    recruits <- alpha*Nadults*exp(-log(alpha)/beta*Nadults)
  }
  return(list("recruits"=recruits))
}

curve(population_model(alpha=alpha,beta=beta,Nadults=x,model="Beverton-Holt")$recruits,from=0,to=2*beta,lwd=2,col="orange",xlab="Adults (t-1)",ylab="Recruits (t)",ylim=c(0,2*beta))
curve(population_model(alpha=alpha,beta=beta,Nadults=x,model="Ricker")$recruits,from=0,to=2*beta,lwd=2,col="dodgerblue",add=TRUE)
abline(b=1,a=0,lty=3,lwd=1.5,col="grey50")
points(c(beta,beta),c(beta,beta),pch=21,bg="grey50",col="black")
legend("bottomright",c("Beverton-Holt","Ricker","Replacement"),bty="n",lwd=1.5,lty=c(1,1,3),pch=c(NA,NA,21),col=c("orange","dodgerblue","grey50"),pt.bg="grey50",cex=0.8)

```

### MSY
Maximum Sustainable Yield *MSY* is the most fish (biomass or abundance) that can be removed from the population over the long-term given the productivity of the population. It is a very helpful thing to know about the population!

```{r MSY}
umsy_find <- function(u_x,alpha, beta,model="Beverton-Holt")
{
  if(model=="Beverton-Holt")
  {
    # population model is R ~ (CR * S)/(1+(CR-1)/K * S): reparameterized Beverton-Holt
    adults <- (1-u_x)*beta
    recruits <- population_model(alpha=alpha,beta=beta,Nadults=adults,model="Beverton-Holt")$recruits
    yield <- u_x*recruits
  }
  if(model=="Ricker")
  {
    # population model is R ~ CR * S * e(-log(CR)/K * S): reparameterized Ricker
    adults <- (1-u_x)*beta
    recruits <- population_model(alpha=alpha,beta=beta,Nadults=adults,model="Ricker")$recruits
    yield <- u_x*recruits
  }
  return(yield)
}

curve(umsy_find(u_x=x,alpha=alpha,beta=beta),from=0,to=1,xlab="Exploitation rate",ylab="Yield")
umsy <- optimize(umsy_find,c(0,1),tol=0.0001,alpha=alpha,beta=beta,maximum = TRUE)$maximum
S_msy <- (1-umsy)*beta
MSY <- umsy*population_model(alpha=alpha,beta=beta,Nadults=S_msy,model="Beverton-Holt")$recruits

data.frame("U"=umsy,"Smsy"=S_msy,"MSY"=MSY)
```
### Limit reference point: S(gen)
Then, we will estimate one version of a limit reference point called S(gen). S(gen) is the spawner abundance that, in the absence of fishing, can reach S(MSY) within 1 generation. It is a conservation-based benchmark and lets us know how low we can go before we need to close fisheries and still get back to MSY fairly quick.

```{r Sgen}
Sgen_find <- function(Smsy,Sgen,alpha,beta)
{
  (Smsy-population_model(alpha=alpha,beta=beta,Nadults=Sgen,model="Beverton-Holt")$recruits)^2
}

Sgen <- optimize(Sgen_find,c(0,S_msy),tol=0.0001,Smsy=S_msy,alpha=alpha,beta=beta)$minimum
Sgen
```

### Reference points: visualized
Now, we have our reference points for a 1-year generation time population. Let's plot this out:
```{r WSP plot}
plot(0:(2*beta),population_model(alpha=alpha,beta=beta,0:(2*beta))$recruits,xlab="Spawners",ylab="Recruits",type="l",lwd=2)
abline(v=S_msy,lty=2,lwd=2,col="orange3")
abline(v=Sgen,lty=2,lwd=2,col="red3")
abline(a=0,b=1,lty=2,lwd=2,col="grey50")
points(beta,beta,pch=21,bg="grey50",col="black")
legend("bottomright",c("USR","LRP"),bty="n",lwd=1.5,lty=c(1,1),pch=c(NA,NA),col=c("orange3","red3"),cex=0.8)

```

## Case study - example from simulation
### Recruitment stochasticity
We can model stochastic recruitment and, in this case, we will use a lognormal distribution with average variation in recruitment of $\sigma_R$. In cases with stochastic recruitment, the deterministic recruitment in eq. S.4 becomes:

\begin{align}
R_{t}=\cfrac{{\alpha}N_{t-1}}{1+\cfrac{{\alpha}}{\beta}N_{t-1}}e^{\epsilon_{t}-\cfrac{\sigma_{R}^2}{2}}
\end{align}

where lognormal deviates at time *t* is drawn from a normal distribution (*N*) with bias correction $\cfrac{\sigma_{R}^2}{2}$. If $\sigma_R$ is low, then population dynamics approach the deterministic case. In some scenarios, we may want to evaluate the role of temporally correlated recruitment deviates to model potential drivers synchronous or correlated dynamics. Expected recruitment deviates can follow a first-order autoregressive model such that:

\begin{align}
\epsilon_{t}=\rho\epsilon_{t-1}+N(\mu=0,\sigma=\sqrt{\sigma_R^2(1-\rho^2)})
\end{align}


where $\rho$ is temporal correlation (bounded $0-1$). If $\rho$ is 0, then annual recruitment deviates were independent. We modelled the initial conditions for autoregressive recruitment deviates $\epsilon_{1}$ by drawing from a stationary normal distribution with mean $\mu=0$ and variance $\sigma_R^2$ such that:
\begin{align}
\epsilon_{1} \sim N(\mu=0,\sigma=\sigma_R)
\end{align}
We illustrate the effects of two kinds of recruitment deviates below using the same random number generator seed:

```{r recruitment stochasticity, echo=FALSE, warning=FALSE, message = FALSE,fig.width=10,fig.height=5}
Nyears <- 50
seed <- 2025
rho <- 0.8
sigma_r <- 0.5
set.seed(seed)
epsilon <- rnorm(Nyears,mean=0,sd=sigma_r)
N <- recruits <- rep(NA,Nyears)
N[1] <- beta
recruits[1] <- alpha*N[1]/(1+((alpha-1)/beta)*N[1])*exp(epsilon[1])
for(t in 2:Nyears)
{
  N[t] <- recruits[t-1]
  recruits[t] <- alpha*N[t]/(1+((alpha-1)/beta)*N[t])*exp(epsilon[t]-(sigma_r^2)/2)
}
layout(matrix(1:2,ncol=2))
plot(1:Nyears,recruits,xlab="Time",ylim=range(c(0,recruits)),type="l")
plot(N,recruits,xlim=range(c(0,N)),ylim=range(c(0,recruits)))
curve((alpha*x)/(1+((alpha-1)/beta)*x),from=0,lwd=2,col="dodgerblue",add=TRUE)
head(data.frame("Adults"=N,"Recruits"=recruits))

print(c("sd in simulated recruitment (independent)",round(sd(epsilon),2)))

df1 <- data.frame("Year"=1:Nyears,"Adults"=N,"Recruits"=recruits,"variance"="independent")

set.seed(seed)
epsilon <- rnorm(1,mean=0,sd=sigma_r)
N <- recruits <- rep(NA,Nyears)
N[1] <- beta
recruits[1] <- alpha*N[1]/(1+((alpha-1)/beta)*N[1])*exp(epsilon[1])
for(t in 2:Nyears)
{
  epsilon[t] <- rho*epsilon[t-1] + rnorm(1,mean=0,sd=sqrt((sigma_r^2)*(1-rho^2)))
  N[t] <- recruits[t-1]
  recruits[t] <- alpha*N[t]/(1+((alpha-1)/beta)*N[t])*exp(epsilon[t]-(sigma_r^2)/2)
}

layout(matrix(1:2,ncol=2))
plot(1:Nyears,recruits,xlab="Time",ylim=range(c(0,recruits)),type="l")
plot(N,recruits,xlim=range(c(0,N)),ylim=range(c(0,recruits)))
curve((alpha*x)/(1+((alpha-1)/beta)*x),from=0,lwd=2,col="dodgerblue",add=TRUE)
head(data.frame("Adults"=N,"Recruits"=recruits))

print(c("sd in simulated recruitment (correlated)",round(sd(epsilon),2)))

df2 <- data.frame("Year"=1:Nyears,"Adults"=N,"Recruits"=recruits,"variance"="correlated")

df <- rbind(df1,df2)
```

## Estimating recruitment model
Let's estimate the Beverton-Holt
```{r optim, echo=FALSE, warning=FALSE, message = FALSE}

df_sub <- df[df$variance=="independent",]
mle_fit <- function(par,dataset)
{
  # theta <- start
  alpha <- exp(par[1])
  beta <- par[2]
  sigma <- exp(par[3])
  # data <- df_sub
  mu <- (alpha*dataset$Adults)/(1+((alpha-1)/beta)*dataset$Adults)
  log_lik <- dlnorm(x=dataset$Recruits,meanlog=log(mu)+((sigma^2)/2),sdlog=sigma,log=TRUE)
  nll <- -sum(log_lik)
  return(nll)
}
start <- c(log(2),mean(df_sub$Recruits),0)
fit <- optim(par=start,fn=mle_fit,dataset=df_sub,method="BFGS",hessian=TRUE)
par <- fit$par
alpha_est <- exp(par[1])
beta_est <- par[2]
sigma_est <- exp(par[3])

parameters <- data.frame("alpha"=c(alpha,alpha_est),"beta"=c(beta,beta_est),"sigma"=c(sigma_r,sigma_est),"type"=c("true","estimate"))
parameters
```

## References
<div id="refs"></div>